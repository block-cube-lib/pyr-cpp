/**
 * @file
 * @author    block
 * @copyright 2016 block (c)copyright all rights reserved.
 */

#include <chrono>

namespace pyrite
{
/**
 * Class stopwatch measures elapsed time.
 */
class stopwatch
{
private:
  using nanoseconds = std::chrono::nanoseconds;              // nanoseconds type
  using time_point  = std::chrono::steady_clock::time_point; // time_point type

public:
  /**
   * Default constructor.
   * start measures.
   */
  stopwatch() noexcept { restart(); }

  /**
   * Copy constructor.
   * generated by the compiler.
   */
  stopwatch( stopwatch const& ) noexcept = default;

  /**
   * Move constructor.
   * generated by the compiler.
   */
  stopwatch( stopwatch&& ) noexcept = default;

  /**
   * Destructor.
   * generated by the compiler.
   */
  ~stopwatch() = default;

  void reset()
  {
    nanoseconds_ = nanoseconds{0};
    is_running_  = false;
  }

  void start()
  {
    if( !is_running() )
    {
      start_time_point_ = std::chrono::steady_clock::now();
      is_running_       = true;
    }
  }

  void restart()
  {
    reset();
    start();
  }

  void stop()
  {
    if( is_running() )
    {
      nanoseconds_ += from_startd();
      is_running_ = false;
    }
  }

  bool is_running() const noexcept { return is_running_; }

  template <typename Duration>
  typename Duration::rep elapsed() const noexcept
  {
    auto const count = nanoseconds_ + from_startd();
    return std::chrono::duration_cast<Duration>( count ).count();
  }

  template <typename T>
  T elapsed_seconds() const noexcept
  {
    using result_t = std::chrono::duration<T, std::ratio<1, 1>>;
    return elapsed<result_t>();
  }

  template <typename T>
  T elapsed_milliseconds() const noexcept
  {
    using result_t = std::chrono::duration<T, std::ratio<1, 1000>>;
    return elapsed<result_t>();
  }

  stopwatch& operator=( stopwatch const& ) = default;
  stopwatch& operator=( stopwatch&& ) = default;

private:
  nanoseconds from_startd() const noexcept
  {
    if( is_running() )
    {
      auto const now      = std::chrono::steady_clock::now();
      auto const duration = now - start_time_point_;
      return std::chrono::duration_cast<nanoseconds>( duration );
    }
    else
    {
      return nanoseconds{0};
    }
  }

private:
  nanoseconds nanoseconds_{0};     // count nanoseconds
  time_point  start_time_point_{}; // time point
  bool        is_running_{false};
};
} // namespace pyrite
